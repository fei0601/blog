<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bower的使用]]></title>
    <url>%2Fblog%2F2017%2F09%2F28%2Fbower%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Bower的使用1 Bower简介 Bower官网 其功能和npm类似.利用bower可以管理插件/类库.是1个前端包管理工具. 其直接从github下载.其依赖于git和npm Bower是1个前端的插件市场 npm是1个前后端的插件市场. npm https://www.npmjs.com/ bower github 2. Bower安装 安装nodejs 拥有npm工具. 安装git 使用npm安装bower npm install -g bower 3. Bower使用 可以在git bash中使用使用bower,也可以直接在命令行工具中使用bower 一般使用步骤 初始化bower bower init 该命令用来在项目文件夹中初始化bower环境,生成配置文件. 使用bower install xxx --save命令来进行安装. 会在当前项目目录下生成1个bower_components目录,将包存储在其中. 指定下载目录的方式. 新建.bowerrc文件 {directory:&quot;app/vendor&quot;} 使用bower uninstall xxx --save命令来移除包4. Bower的特点 如果A包依赖于B包.那么在下载A包的时候 会自动下载B包. 在A包没有删除的情况下,无法删除B包. 在删除A包的时候,如果无其他包依赖A 会连着A一起删除.否则不会删除A.]]></content>
      <tags>
        <tag>技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp的简单使用]]></title>
    <url>%2Fblog%2F2017%2F09%2F27%2Fgulp%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[gulp123456789多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的；使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析；合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能；这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack 1. gulp简介 gulp这个软件是用nodejs写的. gulp是基于流的自动化构建工具 网站开发完成之后,我们要做项目构建,完成之后才可以上线. 项目构建: 代码压缩.html css js 代码混淆 文件合并 等其它自动化工作. sass转换为css. 这就是gulp做的事情. 2. gulp安装 首先需要全局安装gulp,如果之前已经全局安装过,可以省略这步. 123456npm install gulp -gglobal 全局安装. 会把该软件安装到系统目录中.我们使用npm下载插件,实际上是从https://www.npmjs.com/下载.全局安装的插件 可以在任意的地方使用.本地安装的插件 只能在当前项目中使用.使用gulp -v命令查看安装的gulp版本 如果可以看到就说明安装成功. 还需要本地安装,在项目目录中. 1npm install gulp --save 3. gulp使用 在项目目录中新建1个gulpfile.js文件. 在这个文件中写上构建代码. 先引入本地的gulp模块 12var gulp = require('gulp');//这个gulp对象就可以配合插件来进行构建工作. 3.1 创建任务 gulp是以任务的形式来执行每一项构建化工作. 调用gulp对象的task方法可以创建任务 参数1: 任务名称 参数2: 回调函数,执行该任务的时候,要做的事情. 123gulp.task("testTask",function()&#123; console.log();&#125;); 这个时候,我们就创建了1个任务testTask,该任务做的事情就是回调函数的事情. 3.2 执行任务 如何执行这个gulp任务呢? 打开cmd工具,切换工作路径到项目目录 在命令行窗口中使用gulp 任务名称就可以执行指定的任务. 1gulp testTask 这个时候,名叫testTask的任务就会被执行. 4.压缩CSS gulp-cssmin 需要创建1个压缩css的任务. 12345678910111213141516var cssmin = require("gulp-cssmin");gulp.task("yscss",function () &#123; //1.这个任务是用来压缩css的. // 那么首先你需要指定需要压缩的css文件 // 调用gulp对象的src方法,指定要处理的文件的路径. gulp.src("./src/assets/css/reset.css") .pipe(cssmin()) .pipe(gulp.dest("./dist/assets/css")); //2.pipe()管道理解 阀门形象理解. //3.管道中每一个阀门做不同的事情.不同的事情需要插件来完成. // 压缩css的插件. gulp-cssmin // 安装插件,引入gulp-cssmin // 引入后,其实1个函数. // 将其在管道中调用,相当于在管道中设置了1个阀门. //4.管道最后1关,要调用gulp对象的dest方法,设置存放处理后的路径.&#125;); 5.文件监视 watch gulp对象提供了一个watch方法 该方法的作用,监视指定文件的变化, 一旦改动,就执行指定的任务 1234gulp.task("watchCss",function () &#123; //监视指定的css文件.可以使用通配符,一旦文件发送变化,就自动执行yscss任务 gulp.watch("./src/assets/css/reset.css",["yscss"]);&#125;) watch方法的第2个参数,还可以是1个回调.当文件发生变化以后,就执行这个回调. 5.gulp-uglify 压缩js 压缩混淆js代码,需要gulp-uglify插件支持.使用npm安装该插件. 12345678910//1.引入gulp模块var gulp = require("gulp");//2.引入gulp-uglify模块.返回的是1个函数.var uglify = require("gulp-uglify");//3.新建任务gulp.task("ysjs",function()&#123; gulp.src("./js/app.js") .pipe(uglify()) .pipe(gulp.dest("./dist/js"));&#125;); 6.gulp-concat 合并文件 文件合并需要使用到 gulp-concat插件支持.使用npm安装该插件. 123456gulp.task("concatFile",function()&#123; gulp.src(["./src/js/app.js","./src/js/demo.js"]) .pipe(concat("all.js"))//将待处理的文件进行合并,合并后的新文件的名称为 all.js .pipe(uglify())//再混淆 .pipe(gulp.dest("./dist/js"));&#125;); 7.gulp-htmlmin 压缩html文件 压缩html代码需要使用到 gulp-htmlmin插件支持.使用npm安装该插件. 12345678gulp.task("yshtml",function()&#123; gulp.src("./src/index.html") .pipe(htmlmin(&#123; collapseWhitespace:true, //去空格 removeComments:true//去注释 &#125;)) .pipe(gulp.dest("./dist"))&#125;); 8.gulp-sass 将sass转换为 css123456gulp.task("sass2css",function()&#123; gulp.src("./src/css/index.scss") .pipe(sass()) .pipe(cssmin()) .pipe(gulp.dest("./dist/css"));&#125;); 9. gulp-less 将less转换为 css10. gulp-imagemin 压缩图片]]></content>
      <tags>
        <tag>技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2Fblog%2F2017%2F09%2F27%2F%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他# 生成一个可供发布的压缩包 $ git archive ####]]></content>
      <tags>
        <tag>技术文档</tag>
      </tags>
  </entry>
</search>
